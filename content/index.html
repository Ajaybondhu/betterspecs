---
title: 'Better Specs'
---

<article>

<aside class="menu">

<h1>Affiliate books</h1>

  <ul class="media-grid">
    <li>
    <a href="http://www.amazon.com/gp/product/1934356646/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1934356646&linkCode=as2&tag=httpbettersco-20"><img class="thumbnail" src="/images/rails-test-prescription-thumb.jpg" alt="ioBridge"></a>
    </li>
    <li>
    <a href="http://www.amazon.com/gp/product/1934356379/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1934356379&linkCode=as2&tag=httpbettersco-20"><img class="thumbnail" src="/images/the-rspec-book-thumb.jpg" alt="ioBridge"></a>
    </li>
    <li>
    <a href="http://www.amazon.com/gp/product/1934356808/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1934356808&linkCode=as2&tag=httpbettersco-20"><img class="thumbnail" src="/images/continuous-testing-thumb.jpg" alt="ioBridge"></a>
    </li>
    <!--<li>-->
    <!--<a href="http://www.amazon.com/gp/product/1934356700/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1934356700&linkCode=as2&tag=httpbettersco-20"><img class="thumbnail" src="/images/the-cucumber-book-thumb.jpg" alt="ioBridge"></a>-->
    <!--</li>-->
  </ul>

</aside>

</article>

<article>

<h1><a name="introduction">Introduction</a></h1>

<p>
<a href="https://www.relishapp.com/rspec/">RSpec</a> is a great tool in the behavior
driven design process of writing human readable specifications that direct and validate
the development of your application. 
</p>

<p>
On the web you can find several resources explaining how to
use RSpec and all they gives you a complete overview of what you can do. What you'll
rarely find is a book or an article explaining how to use RSpec to create a
great test suite.
<p>

<p>
Better Specs tries to fill this miss collecting most of the best practices developers
has been learning the hard way through years of experience.
</p>

</article>

<article>

<h1><a name="describe">How to describe your methods</a></h1>

<p>
Keep clear the methods you are describing. As convention use <code>.</code> as prefix for
class methods and <code>#</code> as prefix for instance methods.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">describe 'the authenticate method for User' do
describe 'if the user is an admin' do
</code></pre>
</div>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">describe '.authenticate' do
describe '#admin?' do
</code></pre>
</div>

</article>

<article>

<h1><a name="contexts">Use contexts</a></h1>

<p>
Contexts are a powerful method to make your tests clear and well organized.
In the long term this practice will keep tests easy to read.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">it 'should have 200 status code if logged in' do
  response.should respond_with 200
end
it 'should have 401 status code if not logged in' do
  response.should respond_with 401
end
</code></pre>
</div>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">context 'when logged in' do
  it { should respond_with 200 }
end
context 'when logged out' do
  it { should respond_with 401 }
end
</code></pre>
</div>

<p>
  When describing contexts, make them start always using the keys
  <code>when</code> and <code>with</code>.
</p>

</article>

<article>

<h1><a name="short">Keep your description short</a></h1>

<p>
A spec description should never be longer than 40 characters. If this happens
you should split it using a context.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">it 'should have 422 status code if an unexpected params will be added' do
</code></pre>
</div>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">context 'when not valid'
  it { should respond_with 422 }
</code></pre>
</div>

<p>
In the example we removed the description related to the status code,
which has been replaced by the expectation <code>it { should respond_with 422 }</code>.
If you run this test typing <code>rspec filename</code> you will obtain a readable output.
</p>

<p class="base">Formatted Output</p>

<div>
<pre><code>when not valid
  it should respond with 422
</code></pre>
</div>

</article>

<article>

<h1><a name="single">Single expectation test</a></h1>

<p>
The 'one expectation' tip is more broadly expressed as 'each test should make only one assertion'.
This helps you on finding possible errors, going directly to the failing test, and to make your
code readable.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">it 'should create a resource' do
  response.should respond_with_content_type(:json)
  response.should assign_to(:resource)
end
</code></pre>
</div>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">it { should respond_with_content_type(:json) }
it { should assign_to(:resource) }
</code></pre>
</div>

<p>
Note that single expectation test does not mean single line test.
</p>

</article>

<article>

<h1><a name="all">Test all possible cases</a></h1>

<p>
Testing is a good practice, but if you do not test the edge cases, it will not
be useful. Test valid, edge and invalid case. For example, consider the following action.
</p>

<p class="base">Destroy action</p>

<div>
<pre><code class="ruby">before_filter :find_owned_resources
before_filter :find_resource

def destroy
  render 'show'
  @consumption.destroy
end</code></pre>
</div>

<p>
The error I usually see lies in testing only whether the resource has been removed.
But there are at least two edge case: when the resource is not found and when it's not
owned. As a rule of thumb think of all the possible inputs and states you can.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">it 'shows the resource'
</code></pre>
</div>

<p class="correct">Correct</p>

<div>
<div class="correct">
<pre><code class="ruby">describe '#destroy' do

  context 'when resource is found' do
    it 'responds with 200'
    it 'shows the resource'
  end

  context 'when resource is not found' do
    it 'responds with 404'
  end

  context 'when resource is not owned' do
    it 'responds with 404'
  end
end
</code></pre>
</div>

</article>

<article>

<h1><a name="subject">Use subject</a></h1>

<p>
If you have several tests related to the same subject use
<code>subject{}</code> to DRY them up.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">it { assigns('message').should match /it was born in Belville/ }
it { assigns('message').creator.should match /Topolino/ }
</code></pre>
</div>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">subject { assigns('message') }
it { should match /it was born in Billville/ }
its(:creator) { should match /Topolino/ }
</code></pre>
</div>

<p>
Remember that using an explicit subject within a specification makes the specs
difficult to read.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">subject { Hero.first }
it "should be equipped with a sword" do
  subject.equipment.should include "sword"
end
</code></pre>
</div>

</article>

<article>

<h1><a name="let">Use let and let!</a></h1>

<p>
When you have to assign a variable instead of using a <code>before</code> block to create
an instance variable, use <code>let</code>. Using <code>let</code> the variable lazy loads
only when it is firstly used in the test and get cached until that specific test is finished.
</p>

<p class="wrong">Wrong</p>

<div>
<pre><code class="ruby">describe '#type_id' do
  before { @resource = FactoryGirl.create :device }
  before { @type     = Type.find resource.type_id }

  it 'sets the type_id field' do
    @resource.type_id.should == type.id
  end
end
</code></pre>
</div>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">describe '#type_id' do
  let(:resource) { FactoryGirl.create :device }
  let(:type)     { Type.find resource.type_id }

  it 'sets the type_id field' do
    resource.type_id.should == type.id
  end
end
</code></pre>
</div>

<p>
Use <code>let</code> to initialize actions that are lazy loaded to test your specs.
</p>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">context 'when updates a not existing property value' do
  let(:properties) { { id: Settings.resource_id, value: 'on'} }
  let(:update)     { resource.properties = properties }

  it 'raises a not found error' do
    expect { update }.to raise_error Mongoid::Errors::DocumentNotFound
  end
end
</code></pre>
</div>

<p>
Use <code>let!</code> if you want to define the variable when the block is defined.
This can be useful to populate your database to test queries or scopes.
</p>

</article>

<article>

<h1><a name="mock">Mock or not to mock</a></h1>

<p>
This is really opinioneted. Do not (over)use mocks and test real behavior when possible. 
As far as I can tell you from my experience you need to test real cases. Anyway, sometimes
they can be pretty useful to updated your application flow.
</p>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby"># simulate a not found resource
context "when not found" do
  before { Resource.stub(:where).with(created_from: params[:id]).and_return(false) }
  it { should respond_with 404 }
end
</code></pre>
</div>

<p>
Some people will tell you that mocking is one of the best way to make your specs fast. It's
true, but it also complicates your test suite. You can have fast tests in other ways (see
<a href="#spork" class="see">faster tests with spork</a> and
<a href="#guard" class="see">automatic tests with guard</a>).
</p>

</article>

<article>

<h1><a name="data">Create only tha data you need</a></h1>

<p>
If you have ever worked in a medium size project (but also in a small ones), test suites
can be heavy to run. To solve this problem, is important to not load more data than needed.
Also if you think you need dozens of records, usually you are wrong.
</p>

<p class="correct">Correct</p>

<div>
<pre><code class="ruby">describe "User"
  describe ".top" do
    before { 3.times { Factory(:user) } }
    it { User.top(2).should have(2).item }
  end
end
</code></pre>
</div>

</article>

<article>

<h1><a name="factories">Use factories and not fixtures</a></h1>

<p>
This is an old topic, but it's still good to remember. Do not use fixtures which are
difficult to control, instead use factories/blueprints. Use them to reduce the verbosity
on creating new data.
</p>

<div class="wrong">
<pre><code class="ruby"># wrong
user = User.create(
  name: 'Genoveffa',
  surname: 'Piccolina',
  city: 'Billyville',
  birth: '17 Agoust 1982',
  active: true
)
</code></pre>
</div>

<div class="correct">
<pre><code class="ruby"># correct
user = FactoryGirl.create :user
</code></pre>
</div>

</article>

<article>

<h1><a name="matchers">Easy to read matcher</a></h1>

<p>
This is taken directly from carbonfive article. Sometimes you feel the need of having readable
matchers. Check out rspec matcher.
</p>

<div class="wrong">
<pre><code class="ruby"># wrong
lambda { model.save! }.should raise_error(ActiveRecord::RecordNotFound)
collection.size.should == 4
</code></pre>
</div>

<div class="correct">
<pre><code class="ruby"># correct
expect { model.save! }.to raise_error(ActiveRecord::RecordNotFound)
collection.should have(4).items
</code></pre>
</div>

</article>

<article>

<h1><a name="shared-examples">Shared Examples</a></h1>

<p>
Making tests is great and you get more confident day after day. But there will be a
point where you will start to see code duplication coming up everywhere. RSpec offers
shared examples to DRY out your test suite.
</p>

<div class="wrong">
<pre><code class="ruby"># wrong
describe '#show'
  context 'when own resources' do
    it 'should have it' do 
      resource = Factory('user') do_get format: json   
      assigns(users).should include(resource)
    end  
  end
  context 'when does not own resource' do
    it 'should not have it' do 
      not_owned_resource = Factory('unknown') do_get     
      format: json assigns(users).should_not include(not_owned_resource)
    end
  end
end
</code></pre>
</div>

<p>
In this example we use the method it_behaves_like which refers to the shared example below.
</p>

<div class="correct">
<pre><code class="ruby"># correct
describe "#show" do 
  it_should_behave_like "a secure resource"
end

shared_examples_for "a secure resource" do
  context "when own the resource" do 
    it "should have it" do
      resource = Factory("user") 
      do_get format: json 
      assigns(users).should include(resource)
    end 
  end
  context "when does not own resource" do 
    it "should not have it" do
      not_owned_resource = Factory("unknown") 
      do_get format: json 
      assigns(users).should_not include(not_owned_resource)
    end 
  end
end
</code></pre>
</div>

</article>

<article>

<h1><a name="integration">Integration tests are better</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="should">Do not use should</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="spork">Faster tests with spork</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="guard">Automatic tests with guard</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="time-specs">Build specs based on time</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="http-mocking">Mocking HTTP requests</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="formatter">Use a useful formatter</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="books">Books</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="resources">Resources on the web</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="libraries">Libraries</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>

<article>

<h1><a name="styleguide">Styleguide</a></h1>

<p>
<span class="label notice warning">todo</span>
</p>

</article>
